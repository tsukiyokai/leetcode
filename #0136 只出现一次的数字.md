## 题目

```
给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。
```

## 解法

### 思路

```
位运算
```

### 代码

```c++
class Solution {
public:
    int singleNumber(vector<int>& nums) {
        int res = nums[0];
        for (auto i = 1; i < nums.size(); ++i) {
            res = res ^ nums[i];
        }
        return res;
    }
};
```

### 注释

```
常规操作是一边遍历数组一边用哈希表统计元素出现的次数，最后再遍历哈希表，看看哪个数只出现了一次。
时间复杂度为O(n)，空间复杂度为O(n)。

异或的性质
性质1：两个相同的数异或，运算结果为 0   n ^ n = 0
性质2：任何数和 0 异或，运算结果不变   n ^ 0 = n
性质3：支持交换律和结合律，例如 x ^ ( y ^ x) = (x ^ y) ^ x

若利用以上性质，两个相同的数异或的结果是 0，一个数和 0 异或的结果是它本身，所以我们把这组整型全部异或一下。
例如这组数据是1,2,3,4,5,1,2,3,4。其中5只出现了一次，其他都出现了两次，把他们全部异或一下，结果如下：
由于异或支持交换律和结合律，所以: 1^2^3^4^5^1^2^3^4 = (1^1)^(2^2)^(3^3)^(4^4)^5= 0^0^0^0^5 = 5。

通过这种方法，可以把空间复杂度降低到 O(1)，而时间复杂度不变。
```

## 附录 - Bitwise operation

#### 用 位运算 可以代替一些普通操作。

```
n / 2 等价于 n >> 1
n / 4 等价于 n >> 2
n / 8 等价于 n >> 3

Right shift (>>) operator is equivalent to division by 2
Left shift (<<) operator is equivalent to multiplication by 2
```

#### 用 位运算 可以判断奇偶性。

```
普通写法：
if( n % 2 == 1 ) return ODD;
简写：
if( n % 2 ) return ODD;

位运算写法：
if( (n & 1) == 1 ) return ODD;
简写：
if( n & 1 ) return ODD;
或者：
bool IsOdd(int i) { return i & 1; }
```

#### n&(n - 1) 的妙用。

```
n & (n - 1) 功能：消去 n 的二进制表示中的最右边的 1

用处：

1. 判断一个正整数 n 是否为 2 的幂次方。
如果一个数是 2 的幂次方，意味着 n 的二进制表示中，只有一个位是 1 ，其他都是 0 。举个例子，例如：
2^0 = 0……0001
2^1 = 0……0010
2^2 = 0……0100
所以，对一个正整数 n 执行 n & (n - 1) ，结果得到 0 ，说明是 2 的幂次方，否则不是。
代码示范：
bool judege(int n) {
    return (n & (n - 1)) == 0;
}
如果 n 是 2 的幂次方，则返回 true

2. 判断正整数 n 的二进制表示中有多少个 1 。
每执行一次 n & (n - 1) 时， n 的二进制表示中消去一位最右边的 1 ，消去所有 1 时， n 变成 0 。
欲知 n 中有多少个 1 ，只需计算总共执行了多少次。
代码示范：
while (n != 0) {
    count++;
    n = (n - 1) & n;
}
return count;

3. 整数 m 和 n 有多少位二进制位不同？
首先执行 m ^ n ，相同位取得 0 ，相异位取得 1 。
于是转化成第 2 种情况，检查上述结果有多少个 1 即可。
```

#### 异或的妙用

```
性质1：两个相同的数异或，运算结果为 0，例如 n^n=0
性质2：任何数和 0 异或，运算结果不变，例如 n^0= n
性质3：支持交换律和结合律，例如 x^(y^x)=(x^y)^x

例题：
数组中，只有一个数出现一次，剩下都出现两次，请找出仅出现一次的数。

常规操作：
一边遍历数组一边用哈希表统计元素出现的次数，最后再遍历哈希表，看看哪个数只出现了一次。时间复杂度为O(n)，空间复杂度为O(n)。

特殊技巧：
利用异或的几个性质，两个相同的数异或的结果是 0，一个数和 0 异或的结果是它本身，所以我们把这组整型全部异或一下。
例如这组数据是1,2,3,4,5,1,2,3,4。其中5只出现了一次，其他都出现了两次，把他们全部异或一下，结果如下：
由于异或支持交换律和结合律，所以: 1^2^3^4^5^1^2^3^4 = (1^1)^(2^2)^(3^3)^(4^4)^5= 0^0^0^0^5 = 5。

通过这种方法，可以把空间复杂度降低到 O(1)，而时间复杂度不变。
代码示范：
int find(int[] arr) {
    int tmp = arr[0];
    for (int i = 1; i < arr.length; i++) {
        tmp = tmp ^ arr[i];
    }
    return tmp;
}
```

