## 题目

```
假设你正在爬楼梯。需要 n 阶你才能到达楼顶。
每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？
```

## 解法一

### 思路

```
经典递归
```

### 代码

```c++
class Solution {
public:
	unsigned climbStairs(int n) {
		int res = 0;
		if (n == 1) return 1;
		if (n == 2) return 2;
		return climbStairs(n - 1) + climbStairs(n - 2);
	}
};
```

### 分析

```
超时
经典递归是一种不进入问题而解决问题的思想，有极多的重复计算。
```

## 解法二

### 思路

```
DP
```

### 代码

```c++
// 版本一
class Solution {
public:
	int climbStairs(int n) {
		if (n <= 1) return n; // 因为下面直接对dp[2]操作了，防止空指针
		vector<int> dp(n + 1);
		dp[1] = 1;
		dp[2] = 2;
		for (int i = 3; i <= n; i++) { // 注意i是从3开始的
			dp[i] = dp[i - 1] + dp[i - 2];
		}
		return dp[n];
	}
};
// 时间复杂度 O(N)
// 空间复杂度 O(N)
```

```c++
// 版本二
class Solution {
public:
	int climbStairs(int n) {
		if (n <= 1) return n;
		int dp[3];
		dp[1] = 1;
		dp[2] = 2;
		for (int i = 3; i <= n; i++) {
			int tmp = dp[1] + dp[2];
			dp[1] = dp[2];
			dp[2] = tmp;
		}
		return dp[2];
	}
};
// 时间复杂度 O(N)
// 空间复杂度 O(1)
```

