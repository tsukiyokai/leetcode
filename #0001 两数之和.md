## 题目

```
给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出和为目标值的那两个整数，并返回它们的数组下标。
你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。
你可以按任意顺序返回答案。 
```

## 解法一

### 思路

```
枚举 暴力
```

### 代码

```c++
class Solution {
public:
	vector<int> twoSum(vector<int>& nums, int target) {
		vector<int> res;
		for (int i = 0; i < nums.size(); i++) {
			for (int j = i + 1; j < nums.size(); j++) {
				if (nums[i] + nums[j] == target) {
					res.push_back(i);
					res.push_back(j);
				}
			}
		}
		return res;
	}
};
```

------

## 解法二

### 思路

```
枚举 哈希
```

### 代码

```c++
class Solution {
public:
	vector<int> twoSum(vector<int>& nums, int target) {
		map<int, int> hashtable;
		for (int i = 0; i < nums.size(); ++i)
		{
			auto it = hashtable.find(target - nums[i]);
			if (it != hashtable.end()) return { it->second, i };
			hashtable[nums[i]] = i;
		}
		return {};
	}
};
```

### 注释

```c++
auto it = hashtable.find(target - nums[i]); // 一把钥匙一个锁，直接找锁头；找不到就返回end函数返回的迭代器
if (it != hashtable.end()) return { it->second, i }; // 说明找到了
hashtable[nums[i]] = i; // 走到这里就是妹找到

map内部实现细节
    map內部的实现自建一颗红黑树，这颗树具有对数据自动排序的功能。因此在map内部所有的数据都是有序的。

map.find()用法
    map.find()返回一个迭代器。当数据出现时，它返回数据所在位置的迭代器，如果map中没有要查找的数据，它返回的迭代器等于end函数返回的迭代器。
    end函数则用于返回迭代器，该迭代器指向map的最后一个元素之后的地址。
    
map[]下标操作细节
    利用[]下标操作的含义是：如果这个key存在，就更新value；如果key不存在，就创建这个key－value对
    实例：map[key] = value
    而映射map的结构正是：key(nums[01234]) | value(01234)
    find函数也是在第一列key中进行搜寻的。
    可见。map的[]中放的并非是下标索引，而是关键字值。
```